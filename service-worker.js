import { cleanupOutdatedCaches, preachAndRoute } from 'workbox-precaching';
import { clientsClaim } from 'workbox-core';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

// -- Workbox Configuration --

// clean old assets
cleanupOutdatedCaches();

// allow SW to control page immediately
self.skipWaiting();
clientsClaim();

// Precache all assets generated by Vite
// self.__WB_MANIFEST is injected by VitePWA
const manifest = self.__WB_MANIFEST;
if (manifest) {
    // In some cases __WB_MANIFEST might be empty or undefined depending on config
    // workbox.precaching.precacheAndRoute(manifest);
    // Since we are using module imports, we need to use the imported function
    // But wait, 'workbox-precaching' export 'precacheAndRoute'
    // I need to be careful with imports in the final bundle unless I use a bundler for SW.
    // VitePWA handles the bundling of the SW if 'injectManifest' is used with a TS/JS source.
    // So 'import' syntax is valid.

    // HOWEVER, I should check if 'workbox-precaching' is installed or if I should use CDN imports or 'virtual:pwa-register'.
    // Typically with 'injectManifest', Vite compiles the SW using esbuild.

}
// Actually, standard way with injectManifest and valid types:
import { precacheAndRoute } from 'workbox-precaching';
precacheAndRoute(self.__WB_MANIFEST);


// -- Caching Strategies --

// 1. Cache Supabase Storage Images (CacheFirst)
registerRoute(
    ({ url }) => url.origin === 'https://tkvjcqgqjysjndpokrvr.supabase.co' && url.pathname.startsWith('/storage/v1/object/public/'),
    new CacheFirst({
        cacheName: 'supabase-storage-images',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            }),
        ],
    })
);

// 2. Cache API Requests (NetworkFirst) - for Supabase REST
registerRoute(
    ({ url }) => url.origin === 'https://tkvjcqgqjysjndpokrvr.supabase.co' && url.pathname.startsWith('/rest/v1/'),
    new NetworkFirst({
        cacheName: 'supabase-api-cache',
        plugins: [
            new CacheableResponsePlugin({
                statuses: [0, 200],
            }),
            new ExpirationPlugin({
                maxEntries: 100,
                maxAgeSeconds: 24 * 60 * 60, // 24 Hours
            }),
        ],
        networkTimeoutSeconds: 10,
    })
);


// -- Background Sync --

const bgSyncPlugin = new BackgroundSyncPlugin('sync-orcamentos', {
    maxRetentionTime: 24 * 60, // Retry for 24 Hours (specified in minutes)
});

// Register route for POST/PUT/DELETE requests to Supabase (if offline)
// Note: Supabase auth headers might expire, so this is tricky, but basic sync is requested.
registerRoute(
    ({ url, request }) => url.origin === 'https://tkvjcqgqjysjndpokrvr.supabase.co' &&
        url.pathname.startsWith('/rest/v1/') &&
        ['POST', 'PUT', 'PATCH', 'DELETE'].includes(request.method),
    new NetworkFirst({
        cacheName: 'supabase-mutations-queue',
        plugins: [bgSyncPlugin],
        networkTimeoutSeconds: 10
    }),
    'POST' // This argument in registerRoute third param is 'method' if second is handler. 
    // Actually registerRoute(match, handler, method)
);
// Workbox registerRoute supports method as 3rd arg.
// But we want to match multiple methods. The match callback handles it.


// -- Push Notifications --
self.addEventListener('push', (event) => {
    // Basic push handler
    let data = {};
    if (event.data) {
        data = event.data.json();
    }

    const title = data.title || 'Marcenaria Pro';
    const options = {
        body: data.body || 'Nova notificação',
        icon: '/pwa-192x192.png',
        badge: '/pwa-192x192.png',
        data: data.url || '/'
    };

    event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    event.waitUntil(
        clients.matchAll({ type: 'window', includeUncontrolled: true }).then(windowClients => {
            if (windowClients.length > 0) {
                windowClients[0].focus();
                if (event.notification.data) {
                    windowClients[0].navigate(event.notification.data);
                }
            } else {
                clients.openWindow(event.notification.data || '/');
            }
        })
    );
});
